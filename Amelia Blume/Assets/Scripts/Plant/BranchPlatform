using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

// Don't extend MonoBehavious because this script will never be attached to a GameObject.
// It's simply an Object that will be used by another script.
public class BranchPlatform : Branch
{
	// standard branch constructor
	public BranchPlatform(TreePlant_Procedural.TreeSettings ts, Branch parentBranch, Vector3 dir, float len, float tms, int node = -1)
	{
		// parentBranch SHOULD be the trunk of the tree.

		// parentBranch determines what branch this branch will... branch... off of.
		// node determines where along the parent branch this branch will protrude from
		// we determine the actual start point from the parent branch's node

		skeleton = new List<BranchNode>();

		parent = parentBranch;
		parentNode = node;

		// -1 is code for "the end of the branch"
		if (parentNode == -1)
		{
			int count = parent.skeleton.Count;
			if (count > 1)
			{
				parentNode = count - 2;
			}
			else
			{
				parentNode = 0;
			}
		}

		children = new List<Branch>();
		depth = parent.getDepth() + 1;
		treeSettings = ts;
		startPoint = parent.skeleton[parentNode].startPoint;
		direction = dir;
		trajectory = direction;
		maxNodeAngle = 5f;

		// determine lengthGoal
		float plr = parent.getLengthRemaining(parentNode);
		lengthGoal = len;
		thickness = treeSettings.branchMaxWidth / (depth + 1);

		skeleton.Add(new BranchNode(thickness, 0, startPoint, direction));

		// branchMaturity = Mathf.Clamp01(getLength() / lengthGoal);
		treeMaturityStart = tms;
	}

	protected override void addSegment(float rad, float magnitude, Vector3 direction)
	{
		// since the tip is always of uniform length, we are actually adding a new tip,
		// and shrinking the previous end segment. It can now grow to its full length,
		// and then the process will start again.

		if (magnitude > treeSettings.branchSegLength)
		{
			Debug.Log("Whoops, magnitude > treeSettings.branchSegLength in addSegment(). We should do something to handle this case.");
		}
		float tipLength = skeleton.Last().length;
		skeleton.Last().length = magnitude;
		BranchNode newNode = new BranchNode(rad, tipLength, skeleton.Last().startPoint + skeleton.Last().getNodeRay(), direction);
		skeleton.Add(newNode);

		// don't grow any children
	}
}